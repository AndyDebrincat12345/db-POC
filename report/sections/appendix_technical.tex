\section{Technical Appendix}

\subsection{Complete Database Schema}

\subsubsection{Base Schema Structure}
\begin{lstlisting}[language=SQL, caption=Complete Database Schema]
-- Users table with authentication and profile information
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    phone VARCHAR(20),
    date_of_birth DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE,
    last_login TIMESTAMP NULL
);

-- Products table for e-commerce functionality
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    price DECIMAL(10,2) NOT NULL,
    sku VARCHAR(50) UNIQUE NOT NULL,
    category_id INT,
    stock_quantity INT DEFAULT 0,
    weight_kg DECIMAL(5,2),
    dimensions_cm VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    is_available BOOLEAN DEFAULT TRUE
);

-- Orders table for transaction management
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    order_number VARCHAR(20) UNIQUE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    status ENUM('pending', 'processing', 'shipped', 'delivered', 'cancelled') DEFAULT 'pending',
    shipping_address TEXT NOT NULL,
    billing_address TEXT,
    payment_method VARCHAR(50),
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    shipped_at TIMESTAMP NULL,
    delivered_at TIMESTAMP NULL
);

-- Order items for detailed transaction tracking
CREATE TABLE order_items (
    id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL DEFAULT 1,
    unit_price DECIMAL(10,2) NOT NULL,
    total_price DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Foreign key relationships
ALTER TABLE order_items 
ADD CONSTRAINT fk_order_items_order 
FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE;

ALTER TABLE order_items 
ADD CONSTRAINT fk_order_items_product 
FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE RESTRICT;

ALTER TABLE orders 
ADD CONSTRAINT fk_orders_user 
FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE RESTRICT;

-- Performance indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_products_sku ON products(sku);
CREATE INDEX idx_products_category ON products(category_id);
CREATE INDEX idx_orders_user ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_order_items_order ON order_items(order_id);
CREATE INDEX idx_order_items_product ON order_items(product_id);
\end{lstlisting}

\subsection{Migration Tool Configurations}

\subsubsection{Bytebase Configuration}
\begin{lstlisting}[language=YAML, caption=Bytebase Configuration]
# bytebase-config.yaml
version: '3.8'
services:
  bytebase:
    image: bytebase/bytebase:latest
    ports:
      - "8080:8080"
    environment:
      - BB_PORT=8080
      - BB_EXTERNAL_URL=http://localhost:8080
      - BB_DATA_DIR=/var/opt/bytebase
      - BB_LOG_LEVEL=INFO
    volumes:
      - bytebase_data:/var/opt/bytebase
    depends_on:
      - postgres
      
  postgres:
    image: postgres:13
    environment:
      - POSTGRES_DB=bytebase
      - POSTGRES_USER=bytebase
      - POSTGRES_PASSWORD=bytebase_pass
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  bytebase_data:
  postgres_data:
\end{lstlisting}

\subsubsection{Liquibase Configuration}
\begin{lstlisting}[language=Properties, caption=Liquibase Properties]
# liquibase.properties
driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/testdb?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC
username=admin
password=admin123
changeLogFile=changelog/db.changelog-master.xml
outputDefaultSchema=false
outputDefaultCatalog=false
logLevel=INFO
\end{lstlisting}

\subsubsection{Python GUI Application Code}
\begin{lstlisting}[language=Python, caption=GUI Migration Manager - Key Functions]
def is_auto_timestamp_column(self, column_name, column_type):
    """Detect auto-generated columns that shouldn't require user input"""
    auto_columns = ['id', 'created_at', 'updated_at']
    timestamp_types = ['timestamp', 'datetime']
    
    # Check if column name suggests auto-generation
    if column_name.lower() in auto_columns:
        return True
    
    # Check if it's a timestamp column with automatic default
    if any(ts_type in column_type.lower() for ts_type in timestamp_types):
        if 'default' in column_type.lower() or 'auto' in column_type.lower():
            return True
    
    return False

def create_row_input_dialog(self, table_name):
    """Create smart input dialog that handles auto-generated columns"""
    cursor = self.mysql_connection.cursor()
    cursor.execute(f"DESCRIBE {table_name}")
    columns = cursor.fetchall()
    
    dialog = tk.Toplevel(self.root)
    dialog.title(f"Add Row to {table_name}")
    dialog.geometry("500x400")
    dialog.configure(bg='white')
    
    # Smart column filtering
    input_fields = {}
    row = 0
    
    for column in columns:
        column_name, column_type = column[0], column[1]
        
        if self.is_auto_timestamp_column(column_name, column_type):
            # Show auto-field information
            info_label = tk.Label(dialog, 
                text=f"{column_name}: Auto-generated", 
                bg='#f0f0f0', fg='#666666', font=('Arial', 9))
            info_label.grid(row=row, column=0, columnspan=2, 
                sticky='w', padx=10, pady=2)
            row += 1
            continue
        
        # Regular input field
        tk.Label(dialog, text=f"{column_name}:", 
            bg='white', font=('Arial', 10, 'bold')).grid(
            row=row, column=0, sticky='w', padx=10, pady=5)
        
        entry = tk.Entry(dialog, font=('Arial', 10), width=30)
        entry.grid(row=row, column=1, padx=10, pady=5)
        input_fields[column_name] = entry
        row += 1
    
    return dialog, input_fields
\end{lstlisting}

\subsection{Performance Benchmarking Scripts}

\subsubsection{Migration Performance Testing}
\begin{lstlisting}[language=Python, caption=Performance Benchmark Script]
import time
import subprocess
import mysql.connector
from contextlib import contextmanager

class MigrationBenchmark:
    def __init__(self):
        self.results = {}
    
    @contextmanager
    def timer(self, operation_name):
        start_time = time.time()
        yield
        end_time = time.time()
        self.results[operation_name] = end_time - start_time
    
    def test_bytebase_migration(self):
        with self.timer("bytebase_full_migration"):
            # Reset database
            subprocess.run(["docker-compose", "down", "-v"], 
                cwd="bytebase/", capture_output=True)
            subprocess.run(["docker-compose", "up", "-d"], 
                cwd="bytebase/", capture_output=True)
            
            # Wait for startup
            time.sleep(10)
            
            # Execute migrations through API
            for i in range(1, 6):
                with self.timer(f"bytebase_migration_{i}"):
                    self.execute_bytebase_migration(f"00{i}")
    
    def test_liquibase_migration(self):
        with self.timer("liquibase_full_migration"):
            subprocess.run(["liquibase", "update"], 
                cwd="liquibase/", capture_output=True)
    
    def test_redgate_migration(self):
        with self.timer("redgate_full_migration"):
            # Direct SQL execution
            connection = mysql.connector.connect(
                host='localhost', user='admin', 
                password='admin123', database='testdb'
            )
            cursor = connection.cursor()
            
            with open('redgate/migrations/schema.sql', 'r') as f:
                schema_sql = f.read()
            
            for statement in schema_sql.split(';'):
                if statement.strip():
                    cursor.execute(statement)
            
            connection.commit()
            connection.close()
    
    def generate_report(self):
        print("Migration Performance Results:")
        print("-" * 40)
        for operation, duration in self.results.items():
            print(f"{operation}: {duration:.3f}s")

# Run benchmark
benchmark = MigrationBenchmark()
benchmark.test_bytebase_migration()
benchmark.test_liquibase_migration()
benchmark.test_redgate_migration()
benchmark.generate_report()
\end{lstlisting}

\subsection{System Requirements and Dependencies}

\subsubsection{Development Environment}
\begin{itemize}
    \item \textbf{Python:} 3.13 with tkinter, mysql-connector-python, requests
    \item \textbf{MySQL:} 8.0.43 Community Server
    \item \textbf{Docker:} 20.10+ with Docker Compose
    \item \textbf{Java:} OpenJDK 11+ (for Liquibase)
    \item \textbf{Operating System:} Windows 10/11, macOS 10.15+, Ubuntu 20.04+
\end{itemize}

\subsubsection{Network and Security Requirements}
\begin{itemize}
    \item \textbf{Ports:} 3306 (MySQL), 8080 (Bytebase), 5432 (PostgreSQL)
    \item \textbf{Firewall:} Allow inbound connections on specified ports
    \item \textbf{SSL/TLS:} Recommended for production deployments
    \item \textbf{Authentication:} Database user with DDL/DML privileges
\end{itemize}
